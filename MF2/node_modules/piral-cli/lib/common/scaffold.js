"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaffoldPiletSourceFiles = exports.scaffoldPiralSourceFiles = void 0;
const path_1 = require("path");
const npm_1 = require("./clients/npm");
const enums_1 = require("./enums");
const io_1 = require("./io");
const log_1 = require("./log");
function getTemplatePackage(templatePackageName) {
    const idx = templatePackageName.indexOf('@', 1);
    const normalizedName = idx > 0 ? templatePackageName.substr(0, idx) : templatePackageName;
    try {
        return require(normalizedName);
    }
    catch (_a) {
        log_1.fail('generalError_0002', `Could not find the given template "${templatePackageName}". Package "${normalizedName}" could not be resolved.`);
    }
}
function getTemplateFiles(templatePackageName, registry, root, data) {
    return __awaiter(this, void 0, void 0, function* () {
        yield npm_1.installPackage(templatePackageName, __dirname, '--registry', registry);
        const templateRunner = getTemplatePackage(templatePackageName);
        if (typeof templateRunner === 'function') {
            return yield templateRunner(root, data);
        }
        else if ('default' in templateRunner && typeof templateRunner.default === 'function') {
            return yield templateRunner.default(root, data);
        }
        else {
            log_1.fail('generalError_0002', `The provided template package "${templatePackageName}" does not export a template factory function.`);
        }
    });
}
function writeFiles(root, files, forceOverwrite) {
    const rootPackage = path_1.resolve(root, 'package.json');
    return Promise.all(files
        .filter((file) => {
        if (typeof file.path !== 'string') {
            log_1.log('generalWarning_0001', `The supplied file path ("${file.path}") is not a string. Skipping.`);
            return false;
        }
        else if (typeof file.content === 'undefined') {
            log_1.log('generalWarning_0001', `The file "${file.path}" did not specify any content. Skipping.`);
            return false;
        }
        return true;
    })
        .map((file) => {
        const target = path_1.resolve(root, file.path);
        const name = path_1.basename(target);
        const dir = path_1.dirname(target);
        if (target !== rootPackage) {
            return io_1.createFileIfNotExists(dir, name, file.content, forceOverwrite);
        }
        else {
            return io_1.updateExistingJson(dir, name, JSON.parse(file.content.toString('utf8')));
        }
    }));
}
function getTemplatePackageName(type, template) {
    if (template.indexOf('/') === -1) {
        return `@smapiot/${type}-template-${template}`;
    }
    return template;
}
function getLanguageName(language) {
    switch (language) {
        case enums_1.SourceLanguage.js:
            return 'js';
        case enums_1.SourceLanguage.ts:
        default:
            return 'ts';
    }
}
function scaffoldPiralSourceFiles(template, registry, language, root, app, packageName, forceOverwrite, variables) {
    return __awaiter(this, void 0, void 0, function* () {
        const src = path_1.dirname(path_1.join(root, app));
        const templatePackageName = getTemplatePackageName('piral', template);
        yield io_1.createDirectory(src);
        const files = yield getTemplateFiles(templatePackageName, registry, root, Object.assign(Object.assign({}, variables), { src, language: getLanguageName(language), packageName }));
        yield writeFiles(root, files, forceOverwrite);
    });
}
exports.scaffoldPiralSourceFiles = scaffoldPiralSourceFiles;
function scaffoldPiletSourceFiles(template, registry, language, root, sourceName, forceOverwrite, variables) {
    return __awaiter(this, void 0, void 0, function* () {
        const src = path_1.join(root, 'src');
        const templatePackageName = getTemplatePackageName('pilet', template);
        yield io_1.createDirectory(src);
        const files = yield getTemplateFiles(templatePackageName, registry, root, Object.assign(Object.assign({}, variables), { src, language: getLanguageName(language), sourceName }));
        yield writeFiles(root, files, forceOverwrite);
    });
}
exports.scaffoldPiletSourceFiles = scaffoldPiletSourceFiles;
//# sourceMappingURL=scaffold.js.map