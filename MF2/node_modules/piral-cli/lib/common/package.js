"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.retrievePiletData = exports.checkAppShellPackage = exports.patchPiletPackage = exports.isValidDependency = exports.retrievePiletsInfo = exports.findPackageVersion = exports.findDependencyVersion = exports.retrievePiralRoot = exports.getPiletsInfo = exports.copyPiralFiles = exports.copyScaffoldingFiles = exports.getFileStats = exports.getPiralPackage = exports.readPiralPackage = exports.findPackageRoot = exports.getPiralPath = void 0;
const path_1 = require("path");
const log_1 = require("./log");
const info_1 = require("./info");
const archive_1 = require("./archive");
const language_1 = require("./language");
const enums_1 = require("./enums");
const compatibility_1 = require("./compatibility");
const constants_1 = require("./constants");
const io_1 = require("./io");
const io_2 = require("./io");
const npm_1 = require("./npm");
const merge_1 = require("./merge");
function getDependencyVersion(name, devDependencies, allDependencies) {
    const version = devDependencies[name];
    const selected = typeof version === 'string' ? version : version === true ? allDependencies[name] : undefined;
    if (!selected) {
        log_1.log('cannotResolveVersion_0052', name);
    }
    return selected || 'latest';
}
const globPatternStartIndicators = ['*', '?', '[', '!(', '?(', '+(', '@('];
function getMatchingFiles(source, target, file) {
    return __awaiter(this, void 0, void 0, function* () {
        const { from, to, deep = true } = typeof file === 'string' ? { from: file, to: file, deep: true } : file;
        const sourcePath = path_1.resolve(source, from);
        const targetPath = path_1.resolve(target, to);
        const isDirectory = yield io_1.checkIsDirectory(sourcePath);
        if (isDirectory) {
            log_1.log('generalDebug_0003', `Matching in directory "${sourcePath}".`);
            const pattern = deep ? '**/*' : '*';
            const files = yield io_1.matchFiles(sourcePath, pattern);
            return files.map((file) => ({
                sourcePath: file,
                targetPath: path_1.resolve(targetPath, path_1.relative(sourcePath, file)),
            }));
        }
        else if (globPatternStartIndicators.some((m) => from.indexOf(m) !== -1)) {
            log_1.log('generalDebug_0003', `Matching using glob "${sourcePath}".`);
            const files = yield io_1.matchFiles(source, from);
            const parts = sourcePath.split('/');
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (globPatternStartIndicators.some((m) => part.indexOf(m) !== -1)) {
                    parts.splice(i, parts.length - i);
                    break;
                }
            }
            const relRoot = parts.join('/');
            const tarRoot = path_1.resolve(target, to);
            return files.map((file) => ({
                sourcePath: file,
                targetPath: path_1.resolve(tarRoot, path_1.relative(relRoot, file)),
            }));
        }
        log_1.log('generalDebug_0003', `Assume direct path source "${sourcePath}".`);
        return [
            {
                sourcePath,
                targetPath,
            },
        ];
    });
}
function getPiralPath(root, name) {
    const path = require.resolve(`${name}/package.json`, {
        paths: [root],
    });
    return path_1.dirname(path);
}
exports.getPiralPath = getPiralPath;
function findPackageRoot(pck, baseDir) {
    try {
        return require.resolve(`${pck}/package.json`, {
            paths: [baseDir],
        });
    }
    catch (ex) {
        log_1.log('generalDebug_0003', `Could not find the package root in "${baseDir}": ${ex}.`);
        return undefined;
    }
}
exports.findPackageRoot = findPackageRoot;
function findPackage(pck, baseDir) {
    if (Array.isArray(pck)) {
        for (const item of pck) {
            const result = findPackage(item, baseDir);
            if (result) {
                return result;
            }
        }
    }
    else {
        const path = findPackageRoot(pck, baseDir);
        if (path) {
            log_1.log('generalDebug_0003', `Following the app package in "${path}" ...`);
            const appPackage = require(path);
            const relPath = appPackage && appPackage.app;
            appPackage.app = relPath && path_1.resolve(path_1.dirname(path), relPath);
            return appPackage;
        }
    }
    return undefined;
}
function readPiralPackage(root, name) {
    log_1.log('generalDebug_0003', `Reading the piral package in "${root}" ...`);
    const path = getPiralPath(root, name);
    return io_2.readJson(path, 'package.json');
}
exports.readPiralPackage = readPiralPackage;
function getPiralPackage(app, language, version, framework, bundler) {
    // take default packages only if piral-core
    const packages = framework !== 'piral-core' ? {} : undefined;
    // take default dev packages only if not piral-base
    const typings = framework === 'piral-base' ? {} : undefined;
    const devDependencies = Object.assign(Object.assign({}, language_1.getDevDependencies(language, typings)), { 'piral-cli': `${version}` });
    const dependencies = Object.assign({}, language_1.getDependencies(language, packages));
    if (bundler && bundler !== 'none') {
        devDependencies[`piral-cli-${bundler}`] = `${version}`;
    }
    return {
        app,
        scripts: {
            start: 'piral debug',
            build: 'piral build',
        },
        pilets: getPiletsInfo({}),
        dependencies,
        devDependencies,
    };
}
exports.getPiralPackage = getPiralPackage;
function getAvailableFiles(root, name, tarBall) {
    return __awaiter(this, void 0, void 0, function* () {
        const source = getPiralPath(root, name);
        log_1.log('generalDebug_0003', `Checking if "files.tar" exists in "${source}" ...`);
        const exists = yield io_2.checkExists(path_1.resolve(source, `${tarBall}.tar`));
        if (exists) {
            yield archive_1.unpackTarball(source, `${tarBall}.tar`);
        }
        log_1.log('generalDebug_0003', `Get matching files from "${source}".`);
        const base = path_1.resolve(source, tarBall);
        const files = yield io_1.matchFiles(base, '**/*');
        return files.map((file) => ({
            sourcePath: file,
            targetPath: path_1.resolve(root, path_1.relative(base, file)),
        }));
    });
}
function getFileStats(root, name) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = yield getAvailableFiles(root, name, constants_1.filesTar);
        return yield Promise.all(files.map((file) => __awaiter(this, void 0, void 0, function* () {
            const { sourcePath, targetPath } = file;
            const sourceHash = yield io_1.getHash(sourcePath);
            log_1.log('generalDebug_0003', `Obtained hash from "${sourcePath}": ${sourceHash}`);
            const targetHash = yield io_1.getHash(targetPath);
            log_1.log('generalDebug_0003', `Obtained hash from "${targetPath}": ${targetHash}`);
            return {
                path: targetPath,
                hash: targetHash,
                changed: sourceHash !== targetHash,
            };
        })));
    });
}
exports.getFileStats = getFileStats;
function copyFiles(subfiles, forceOverwrite, originalFiles) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const subfile of subfiles) {
            const { sourcePath, targetPath } = subfile;
            const exists = yield io_2.checkExists(sourcePath);
            if (exists) {
                const overwrite = originalFiles.some((m) => m.path === targetPath && !m.changed);
                const force = overwrite ? enums_1.ForceOverwrite.yes : forceOverwrite;
                yield io_2.copy(sourcePath, targetPath, force);
            }
            else {
                log_1.fail('cannotFindFile_0046', sourcePath);
            }
        }
    });
}
function copyScaffoldingFiles(source, target, files, piralInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        log_1.log('generalDebug_0003', `Copying the scaffolding files ...`);
        const allFiles = [];
        for (const file of files) {
            const subfiles = yield getMatchingFiles(source, target, file);
            allFiles.push(...subfiles);
        }
        if (piralInfo) {
            yield extendPackageOverridesFromTemplateFragment(target, piralInfo, allFiles);
        }
        yield copyFiles(allFiles, enums_1.ForceOverwrite.yes, []);
    });
}
exports.copyScaffoldingFiles = copyScaffoldingFiles;
function extendPackageOverridesFromTemplateFragment(root, piralInfo, files) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageTarget = path_1.resolve(root, 'package.json');
        for (let i = files.length; i--;) {
            const file = files[i];
            if (file.targetPath === packageTarget) {
                const fragment = yield io_2.readJson(path_1.dirname(file.sourcePath), path_1.basename(file.sourcePath));
                files.splice(i, 1);
                if (!piralInfo.pilets) {
                    piralInfo.pilets = {};
                }
                if (!piralInfo.pilets.packageOverrides) {
                    piralInfo.pilets.packageOverrides = {};
                }
                piralInfo.pilets.packageOverrides = Object.assign(Object.assign({}, piralInfo.pilets.packageOverrides), fragment);
            }
        }
    });
}
function copyPiralFiles(root, name, piralInfo, forceOverwrite, originalFiles) {
    return __awaiter(this, void 0, void 0, function* () {
        log_1.log('generalDebug_0003', `Copying the Piral files ...`);
        const files = yield getAvailableFiles(root, name, constants_1.filesTar);
        if (originalFiles === undefined) {
            const initialFiles = yield getAvailableFiles(root, name, constants_1.filesOnceTar);
            files.push(...initialFiles);
            originalFiles = [];
        }
        yield extendPackageOverridesFromTemplateFragment(root, piralInfo, files);
        yield copyFiles(files, forceOverwrite, originalFiles);
    });
}
exports.copyPiralFiles = copyPiralFiles;
function getPiletsInfo(piralInfo) {
    const { files = [], externals = [], scripts = {}, validators = {}, devDependencies = {}, preScaffold = '', postScaffold = '', preUpgrade = '', postUpgrade = '', packageOverrides = {}, } = piralInfo.pilets || {};
    return {
        files,
        externals,
        scripts,
        validators,
        devDependencies,
        preScaffold,
        postScaffold,
        preUpgrade,
        postUpgrade,
        packageOverrides,
    };
}
exports.getPiletsInfo = getPiletsInfo;
function retrievePiralRoot(baseDir, entry) {
    return __awaiter(this, void 0, void 0, function* () {
        const rootDir = path_1.join(baseDir, entry);
        log_1.log('generalDebug_0003', `Retrieving Piral root from "${rootDir}" ...`);
        if (!constants_1.declarationEntryExtensions.includes(path_1.extname(rootDir).toLowerCase())) {
            const packageName = path_1.basename(rootDir) === 'package.json' ? rootDir : path_1.join(rootDir, 'package.json');
            log_1.log('generalDebug_0003', `Trying to get entry point from "${packageName}".`);
            const exists = yield io_2.checkExists(packageName);
            if (!exists) {
                log_1.fail('entryPointMissing_0070', rootDir);
            }
            const { app } = require(packageName);
            if (!app) {
                log_1.fail('entryPointMissing_0071');
            }
            log_1.log('generalDebug_0003', `Found app entry point in "${app}".`);
            return path_1.join(path_1.dirname(packageName), app);
        }
        log_1.log('generalDebug_0003', `Found app entry point in "${rootDir}".`);
        return rootDir;
    });
}
exports.retrievePiralRoot = retrievePiralRoot;
function checkArrayOrUndefined(obj, key) {
    const items = obj[key];
    if (Array.isArray(items)) {
        return items;
    }
    else if (items !== undefined) {
        log_1.log('expectedArray_0072', key, typeof items);
    }
    return undefined;
}
function findDependencyVersion(pckg, rootPath, packageName) {
    var _a;
    const { devDependencies = {}, dependencies = {} } = pckg;
    const desiredVersion = (_a = dependencies[packageName]) !== null && _a !== void 0 ? _a : devDependencies[packageName];
    if (desiredVersion) {
        if (npm_1.isGitPackage(desiredVersion)) {
            return Promise.resolve(npm_1.makeGitUrl(desiredVersion));
        }
        else if (npm_1.isLocalPackage(rootPath, desiredVersion)) {
            return Promise.resolve(npm_1.makeFilePath(rootPath, desiredVersion));
        }
    }
    return findPackageVersion(rootPath, packageName);
}
exports.findDependencyVersion = findDependencyVersion;
function findPackageVersion(rootPath, packageName) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            log_1.log('generalDebug_0003', `Finding the version of "${packageName}" in "${rootPath}".`);
            const moduleName = require.resolve(packageName, {
                paths: [rootPath],
            });
            const packageJson = yield io_2.findFile(moduleName, 'package.json');
            return require(packageJson).version;
        }
        catch (e) {
            log_1.log('cannotResolveDependency_0053', packageName, rootPath);
            return 'latest';
        }
    });
}
exports.findPackageVersion = findPackageVersion;
function retrievePiletsInfo(entryFile) {
    return __awaiter(this, void 0, void 0, function* () {
        const exists = yield io_2.checkExists(entryFile);
        if (!exists) {
            log_1.fail('entryPointDoesNotExist_0073', entryFile);
        }
        const packageJson = yield io_2.findFile(entryFile, 'package.json');
        if (!packageJson) {
            log_1.fail('packageJsonMissing_0074');
        }
        const packageInfo = require(packageJson);
        return Object.assign(Object.assign({}, getPiletsInfo(packageInfo)), { name: packageInfo.name, version: packageInfo.version, dependencies: {
                std: packageInfo.dependencies || {},
                dev: packageInfo.devDependencies || {},
                peer: packageInfo.peerDependencies || {},
            }, scripts: packageInfo.scripts, ignored: checkArrayOrUndefined(packageInfo, 'preservedDependencies'), root: path_1.dirname(packageJson) });
    });
}
exports.retrievePiletsInfo = retrievePiletsInfo;
function isValidDependency(name) {
    // super simple check at the moment
    // just to filter out things like "redux-saga/effects" and "@scope/redux-saga/effects"
    return name.indexOf('/') === -1 || (name.indexOf('@') === 0 && name.split('/').length < 3);
}
exports.isValidDependency = isValidDependency;
function patchPiletPackage(root, name, version, piralInfo, newInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        log_1.log('generalDebug_0003', `Patching the package.json in "${root}" ...`);
        const _a = getPiletsInfo(piralInfo), { externals, packageOverrides } = _a, info = __rest(_a, ["externals", "packageOverrides"]);
        const piral = {
            comment: 'Keep this section to use the Piral CLI.',
            name,
        };
        const piralDependencies = Object.assign(Object.assign({}, piralInfo.devDependencies), piralInfo.dependencies);
        const typeDependencies = newInfo ? language_1.getDevDependencies(newInfo.language) : {};
        const allExternals = npm_1.makeExternals(externals);
        const scripts = newInfo
            ? Object.assign({ start: 'pilet debug', build: 'pilet build', upgrade: 'pilet upgrade' }, info.scripts) : info.scripts;
        const peerModules = [];
        const peerDependencies = Object.assign(Object.assign({}, allExternals.reduce((deps, name) => {
            const valid = isValidDependency(name);
            deps[name] = valid ? '*' : undefined;
            if (!valid) {
                peerModules.push(name);
            }
            return deps;
        }, {})), { [name]: `*` });
        const devDependencies = Object.assign(Object.assign(Object.assign(Object.assign({}, Object.keys(typeDependencies).reduce((deps, name) => {
            deps[name] = piralDependencies[name] || typeDependencies[name];
            return deps;
        }, {})), Object.keys(info.devDependencies).reduce((deps, name) => {
            deps[name] = getDependencyVersion(name, info.devDependencies, piralDependencies);
            return deps;
        }, {})), allExternals.filter(isValidDependency).reduce((deps, name) => {
            const version = piralDependencies[name];
            if (version || newInfo) {
                // set only if we have an explicit version or we are in the scaffolding case
                deps[name] = version || 'latest';
            }
            return deps;
        }, {})), { [name]: `${version || piralInfo.version}` });
        if (newInfo) {
            const bundler = newInfo.bundler;
            devDependencies['piral-cli'] = `^${info_1.cliVersion}`;
            if (bundler && bundler !== 'none') {
                devDependencies[`piral-cli-${bundler}`] = `^${info_1.cliVersion}`;
            }
        }
        const packageContent = merge_1.deepMerge(packageOverrides, {
            piral,
            devDependencies,
            peerDependencies,
            peerModules,
            dependencies: {
                [name]: undefined,
            },
            scripts,
        });
        yield io_2.updateExistingJson(root, 'package.json', packageContent);
        log_1.log('generalDebug_0003', `Succesfully patched the package.json.`);
    });
}
exports.patchPiletPackage = patchPiletPackage;
/**
 * Returns true if its an emulator package, otherwise it has to be a "raw" app shell.
 */
function checkAppShellPackage(appPackage) {
    const { piralCLI = { generated: false, version: info_1.cliVersion } } = appPackage;
    if (piralCLI.generated) {
        compatibility_1.checkAppShellCompatibility(piralCLI.version);
        return true;
    }
    log_1.log('generalDebug_0003', `Missing "piralCLI" section. Assume raw app shell.`);
    return false;
}
exports.checkAppShellPackage = checkAppShellPackage;
function retrievePiletData(target, app) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJson = yield io_2.findFile(target, 'package.json');
        if (!packageJson) {
            log_1.fail('packageJsonMissing_0075');
        }
        const root = path_1.dirname(packageJson);
        const piletPackage = require(packageJson);
        const appPackage = findPackage(app || (piletPackage.piral && piletPackage.piral.name) || Object.keys(piletPackage.devDependencies), target);
        const appFile = appPackage && appPackage.app;
        if (!appFile) {
            log_1.fail('appInstanceInvalid_0011');
        }
        const emulator = checkAppShellPackage(appPackage);
        return {
            dependencies: piletPackage.dependencies || {},
            devDependencies: piletPackage.devDependencies || {},
            peerDependencies: piletPackage.peerDependencies || {},
            peerModules: piletPackage.peerModules || [],
            ignored: checkArrayOrUndefined(piletPackage, 'preservedDependencies'),
            appFile,
            piletPackage,
            appPackage,
            emulator,
            root,
        };
    });
}
exports.retrievePiletData = retrievePiletData;
//# sourceMappingURL=package.js.map