{"version":3,"file":"windowed-observable.cjs.production.min.js","sources":["../src/observable.ts"],"sourcesContent":["export const EVENTS = '__events__';\nexport const SHARED = '__shared__';\nexport const OBSERVERS = '__observers__';\n\nexport type EventsArray<T = any> = Array<T>;\nexport type Observer<T = any> = (data: T | Array<T> | undefined) => void;\nexport type ObserversArray<T = any> = Array<Observer<T>>;\n\ndeclare global {\n  interface Window {\n    __shared__: {\n      __events__: Record<string, EventsArray>;\n      __observers__: Record<string, ObserversArray>;\n    };\n  }\n}\n\nexport interface SubscriptionOptions {\n  every?: boolean;\n  latest?: boolean;\n}\n\nexport class Observable<T = any> {\n  _namespace!: string;\n\n  private static initialize() {\n    if (!window[SHARED]) {\n      window[SHARED] = {\n        [EVENTS]: {},\n        [OBSERVERS]: {},\n      };\n    }\n    if (!window[SHARED][EVENTS]) {\n      window[SHARED][EVENTS] = {};\n    }\n    if (!window[SHARED][OBSERVERS]) {\n      window[SHARED][OBSERVERS] = {};\n    }\n  }\n\n  constructor(namespace: string) {\n    Observable.initialize();\n\n    this.namespace = namespace;\n  }\n\n  private get events(): EventsArray<T> {\n    return window[SHARED][EVENTS][this._namespace];\n  }\n\n  private set events(newEvents: EventsArray<T>) {\n    window[SHARED][EVENTS][this._namespace] = newEvents;\n  }\n\n  private get observers(): ObserversArray<T> {\n    return window[SHARED][OBSERVERS][this._namespace];\n  }\n\n  private set observers(newObservers: ObserversArray<T>) {\n    window[SHARED][OBSERVERS][this._namespace] = newObservers;\n  }\n\n  set namespace(namespace: string) {\n    this._namespace = namespace;\n\n    if (!this.events) this.events = [];\n    if (!this.observers) this.observers = [];\n  }\n\n  publish(data: T): void {\n    this.observers.forEach((observer: Observer<T>) => observer(data));\n\n    this.events.push(data);\n  }\n\n  dispatch = this.publish;\n\n  subscribe(\n    observer: Observer<T>,\n    options: SubscriptionOptions = { latest: false, every: false }\n  ): void {\n    const { every, latest } = options;\n\n    const events = this.events;\n    const hasOptions = latest || every;\n    if (hasOptions && events.length > 0) {\n      if (latest) {\n        const lastEvent = events[events.length - 1];\n        observer(lastEvent);\n      }\n\n      if (every) {\n        observer(events);\n      }\n    }\n\n    this.observers = this.observers.concat(observer);\n  }\n\n  unsubscribe(observer: Observer<T>): void {\n    this.observers = this.observers.filter((obs) => obs !== observer);\n  }\n\n  clear(): void {\n    this.observers?.forEach((observer: Observer<T>) => observer(undefined));\n\n    this.events = [];\n    this.observers = [];\n  }\n}\n"],"names":["EVENTS","SHARED","OBSERVERS","Observable","namespace","this","publish","initialize","window","data","observers","forEach","observer","events","push","subscribe","options","latest","every","length","concat","unsubscribe","filter","obs","clear","undefined","_namespace","newEvents","newObservers"],"mappings":"wEAAaA,EAAS,aACTC,EAAS,aACTC,EAAY,gBAoBZC,wBAkBCC,iBAmCDC,KAAKC,QAlCdH,EAAWI,kBAENH,UAAYA,IAlBJG,WAAP,iBACDC,OAAOP,KACVO,OAAOP,WACJD,GAAS,KACTE,GAAY,OAGZM,OAAOP,GAAQD,KAClBQ,OAAOP,GAAQD,GAAU,IAEtBQ,OAAOP,GAAQC,KAClBM,OAAOP,GAAQC,GAAa,kCAiChCI,QAAA,SAAQG,QACDC,UAAUC,SAAQ,SAACC,UAA0BA,EAASH,WAEtDI,OAAOC,KAAKL,MAKnBM,UAAA,SACEH,EACAI,YAAAA,IAAAA,EAA+B,CAAEC,QAAQ,EAAOC,OAAO,QAE/CA,EAAkBF,EAAlBE,MAAOD,EAAWD,EAAXC,OAETJ,EAASR,KAAKQ,QACDI,GAAUC,IACXL,EAAOM,OAAS,IAC5BF,GAEFL,EADkBC,EAAOA,EAAOM,OAAS,IAIvCD,GACFN,EAASC,SAIRH,UAAYL,KAAKK,UAAUU,OAAOR,MAGzCS,YAAA,SAAYT,QACLF,UAAYL,KAAKK,UAAUY,QAAO,SAACC,UAAQA,IAAQX,QAG1DY,MAAA,+BACOd,cAAWC,SAAQ,SAACC,UAA0BA,OAASa,WAEvDZ,OAAS,QACTH,UAAY,4CA5DVF,OAAOP,GAAQD,GAAQK,KAAKqB,0BAGlBC,GACjBnB,OAAOP,GAAQD,GAAQK,KAAKqB,YAAcC,2CAInCnB,OAAOP,GAAQC,GAAWG,KAAKqB,0BAGlBE,GACpBpB,OAAOP,GAAQC,GAAWG,KAAKqB,YAAcE,kCAGjCxB,QACPsB,WAAatB,EAEbC,KAAKQ,SAAQR,KAAKQ,OAAS,IAC3BR,KAAKK,YAAWL,KAAKK,UAAY"}