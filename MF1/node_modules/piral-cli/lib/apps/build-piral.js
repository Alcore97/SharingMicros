"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPiral = exports.buildPiralDefaults = void 0;
const path_1 = require("path");
const bundler_1 = require("../bundler");
const types_1 = require("../types");
const common_1 = require("../common");
const releaseName = 'release';
const emulatorName = 'emulator';
const emulatorSourcesName = 'emulator-sources';
function getDestination(entryFiles, target) {
    const isdir = path_1.extname(target) !== '.html';
    if (isdir) {
        return {
            outDir: target,
            outFile: path_1.basename(entryFiles),
        };
    }
    else {
        return {
            outDir: path_1.dirname(target),
            outFile: path_1.basename(target),
        };
    }
}
exports.buildPiralDefaults = {
    entry: './',
    target: './dist',
    publicUrl: '/',
    logLevel: types_1.LogLevels.info,
    fresh: false,
    minify: true,
    type: 'all',
    subdir: true,
    sourceMaps: true,
    contentHash: true,
    optimizeModules: false,
};
function runLifecycle(root, scripts, type) {
    return __awaiter(this, void 0, void 0, function* () {
        const script = scripts === null || scripts === void 0 ? void 0 : scripts[type];
        if (script) {
            common_1.log('generalDebug_0003', `Running "${type}" ("${script}") ...`);
            yield common_1.runScript(script, root);
            common_1.log('generalDebug_0003', `Finished running "${type}".`);
        }
        else {
            common_1.log('generalDebug_0003', `No script for "${type}" found ...`);
        }
    });
}
function buildPiral(baseDir = process.cwd(), options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { entry = exports.buildPiralDefaults.entry, target = exports.buildPiralDefaults.target, publicUrl = exports.buildPiralDefaults.publicUrl, logLevel = exports.buildPiralDefaults.logLevel, minify = exports.buildPiralDefaults.minify, sourceMaps = exports.buildPiralDefaults.sourceMaps, contentHash = exports.buildPiralDefaults.contentHash, subdir = exports.buildPiralDefaults.subdir, fresh = exports.buildPiralDefaults.fresh, type = exports.buildPiralDefaults.type, optimizeModules = exports.buildPiralDefaults.optimizeModules, _ = {}, bundlerName, } = options;
        common_1.setLogLevel(logLevel);
        common_1.progress('Reading configuration ...');
        const useSubdir = type === 'all' || subdir;
        const entryFiles = yield common_1.retrievePiralRoot(baseDir, entry);
        const { name, root, ignored, externals, scripts } = yield common_1.retrievePiletsInfo(entryFiles);
        const dest = getDestination(entryFiles, path_1.resolve(baseDir, target));
        yield common_1.checkCliCompatibility(root);
        if (fresh) {
            common_1.progress('Removing output directory ...');
            yield common_1.removeDirectory(dest.outDir);
        }
        // everything except release -> build emulator
        if (type !== releaseName) {
            const targetDir = useSubdir ? path_1.join(dest.outDir, emulatorName) : dest.outDir;
            common_1.progress('Starting emulator build ...');
            // since we create this anyway let's just pretend we want to have it clean!
            yield common_1.removeDirectory(targetDir);
            common_1.logInfo(`Bundle ${emulatorName} ...`);
            const { dir: outDir, name: outFile } = yield bundler_1.callPiralBuild({
                root,
                piral: name,
                emulator: true,
                optimizeModules,
                sourceMaps,
                contentHash,
                minify: false,
                externals,
                publicUrl,
                outFile: dest.outFile,
                outDir: path_1.join(targetDir, 'app'),
                entryFiles,
                logLevel,
                ignored,
                _,
            }, bundlerName);
            yield runLifecycle(root, scripts, 'piral:postbuild');
            yield runLifecycle(root, scripts, `piral:postbuild-${emulatorName}`);
            const rootDir = yield common_1.createEmulatorSources(root, outDir, outFile, logLevel);
            if (type !== emulatorSourcesName) {
                yield common_1.packageEmulator(rootDir);
                common_1.logDone(`Emulator sources available in "${rootDir}".`);
            }
            else {
                common_1.logDone(`Emulator package available in "${rootDir}".`);
            }
            common_1.logReset();
        }
        // everything except emulator and emulator-soruces -> build release
        if (type !== emulatorName && type !== emulatorSourcesName) {
            const targetDir = useSubdir ? path_1.join(dest.outDir, releaseName) : dest.outDir;
            common_1.progress('Starting release build ...');
            // since we create this anyway let's just pretend we want to have it clean!
            yield common_1.removeDirectory(targetDir);
            common_1.logInfo(`Bundle ${releaseName} ...`);
            const { dir: outDir } = yield bundler_1.callPiralBuild({
                root,
                piral: name,
                emulator: false,
                optimizeModules,
                sourceMaps,
                contentHash,
                minify,
                externals,
                publicUrl,
                outFile: dest.outFile,
                outDir: targetDir,
                entryFiles,
                logLevel,
                ignored,
                _,
            }, bundlerName);
            yield runLifecycle(root, scripts, 'piral:postbuild');
            yield runLifecycle(root, scripts, `piral:postbuild-${releaseName}`);
            common_1.logDone(`Files for publication available in "${outDir}".`);
            common_1.logReset();
        }
    });
}
exports.buildPiral = buildPiral;
//# sourceMappingURL=build-piral.js.map