function defaultFallback(key, language) {
    if (process.env.NODE_ENV === 'production') {
        return language ? '...' : '';
    }
    else {
        if (language) {
            console.warn("Missing translation of \"" + key + "\" in language \"" + language + "\".");
            return "__" + language + "_" + key + "__";
        }
        else {
            return '';
        }
    }
}
function formatMessage(message, variables) {
    return message.replace(/{{\s*([A-Za-z0-9_.]+)\s*}}/g, function (_match, p1) {
        return p1 in variables ? variables[p1] || '' : "{{" + p1 + "}}";
    });
}
var Localizer = /** @class */ (function () {
    /**
     * Creates a new instance of a localizer.
     */
    function Localizer(messages, language, languages, fallback) {
        if (fallback === void 0) { fallback = defaultFallback; }
        this.messages = messages;
        this.language = language;
        this.languages = languages;
        this.fallback = fallback;
    }
    /**
     * Localizes the given key via the global translations.
     * @param key The key of the translation snippet.
     * @param variables The optional variables to use.
     */
    Localizer.prototype.localizeGlobal = function (key, variables) {
        return this.localizeBase(key, variables);
    };
    /**
     * Localizes the given key via the local translations.
     * Uses the global translations as fallback mechanism.
     * @param localMessages The local translations to prefer.
     * @param key The key of the translation snippet.
     * @param variables The optional variables to use.
     */
    Localizer.prototype.localizeLocal = function (localMessages, key, variables) {
        var message = this.translateMessage(localMessages, key, variables);
        if (message === undefined) {
            return this.localizeBase(key, variables);
        }
        return message;
    };
    Localizer.prototype.localizeBase = function (key, variables) {
        var message = this.translateMessage(this.messages, key, variables);
        if (message === undefined) {
            return this.fallback(key, this.language);
        }
        return message;
    };
    Localizer.prototype.translateMessage = function (messages, key, variables) {
        var language = this.language;
        var translations = language && messages[language];
        var translation = translations && translations[key];
        return translation && (variables ? formatMessage(translation, variables) : translation);
    };
    return Localizer;
}());
export { Localizer };
//# sourceMappingURL=localize.js.map