"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncStrategy = exports.standardStrategy = exports.asyncStrategy = exports.blazingStrategy = exports.createProgressiveStrategy = void 0;
var tslib_1 = require("tslib");
var loader_1 = require("./loader");
var load_1 = require("./load");
var aggregate_1 = require("./aggregate");
function evalAll(createApi, oldModules, newModules) {
    if (!Array.isArray(oldModules)) {
        return Promise.reject("The existing pilets must be passed as an array.");
    }
    try {
        var _loop_1 = function (oldModule) {
            var newModule = newModules.filter(function (m) { return m.name === oldModule.name; })[0];
            if (newModule) {
                newModules.splice(newModules.indexOf(newModule), 1);
            }
        };
        for (var _i = 0, oldModules_1 = oldModules; _i < oldModules_1.length; _i++) {
            var oldModule = oldModules_1[_i];
            _loop_1(oldModule);
        }
        return aggregate_1.createPilets(createApi, tslib_1.__spreadArray(tslib_1.__spreadArray([], oldModules), newModules));
    }
    catch (err) {
        return Promise.reject(err);
    }
}
/**
 * This strategy is dependent on the async parameter. If false it will start rendering when
 * everything has been received, otherwise it will start rendering when the metadata has been
 * received. In any case it will evaluate pilets as fast as possible.
 * @param async Uses the asynchronous mode.
 */
function createProgressiveStrategy(async) {
    return function (options, cb) {
        var fetchPilets = options.fetchPilets, fetchDependency = options.fetchDependency, dependencies = options.dependencies, getDependencies = options.getDependencies, createApi = options.createApi, config = options.config, _a = options.pilets, pilets = _a === void 0 ? [] : _a, _b = options.loadPilet, loadPilet = _b === void 0 ? loader_1.createDefaultLoader(dependencies, getDependencies, fetchDependency, config) : _b, loaders = options.loaders;
        var loader = load_1.loadMetadata(fetchPilets);
        var loadSingle = loader_1.extendLoader(loadPilet, loaders);
        return aggregate_1.createPilets(createApi, pilets).then(function (allModules) {
            if (async && allModules.length > 0) {
                cb(undefined, tslib_1.__spreadArray([], allModules));
            }
            var followUp = loader.then(function (metadata) {
                var promises = metadata.map(function (m) {
                    return loadSingle(m).then(function (mod) {
                        var available = pilets.filter(function (m) { return m.name === mod.name; }).length === 0;
                        if (available) {
                            return aggregate_1.createPilet(createApi, mod).then(function (newModule) {
                                allModules.push(newModule);
                                if (async) {
                                    cb(undefined, tslib_1.__spreadArray([], allModules));
                                }
                            });
                        }
                    });
                });
                return Promise.all(promises).then(function () {
                    if (!async) {
                        cb(undefined, allModules);
                    }
                });
            });
            return async ? loader.then() : followUp.then();
        });
    };
}
exports.createProgressiveStrategy = createProgressiveStrategy;
/**
 * This strategy starts rendering when the pilets metadata has been received.
 * Evaluates the pilets once available without waiting for all pilets to be
 * available.
 */
function blazingStrategy(options, cb) {
    var strategy = createProgressiveStrategy(true);
    return strategy(options, cb);
}
exports.blazingStrategy = blazingStrategy;
/**
 * The async strategy picked when no strategy is declared and async is set to
 * true. Directly renders, but waits for all pilets to be available before
 * evaluating them.
 */
function asyncStrategy(options, cb) {
    standardStrategy(options, cb);
    return Promise.resolve();
}
exports.asyncStrategy = asyncStrategy;
/**
 * The standard strategy that is used if no strategy is declared and async is
 * false. Loads and evaluates all pilets before rendering.
 */
function standardStrategy(options, cb) {
    var fetchPilets = options.fetchPilets, fetchDependency = options.fetchDependency, dependencies = options.dependencies, getDependencies = options.getDependencies, createApi = options.createApi, config = options.config, _a = options.pilets, pilets = _a === void 0 ? [] : _a, _b = options.loadPilet, loadPilet = _b === void 0 ? loader_1.createDefaultLoader(dependencies, getDependencies, fetchDependency, config) : _b, loaders = options.loaders;
    var loadSingle = loader_1.extendLoader(loadPilet, loaders);
    return load_1.loadPilets(fetchPilets, loadSingle)
        .then(function (newModules) { return evalAll(createApi, pilets, newModules); })
        .then(function (modules) { return cb(undefined, modules); })
        .catch(function (error) { return cb(error, []); });
}
exports.standardStrategy = standardStrategy;
/**
 * The strategy that could be used for special purposes, e.g., SSR or specific
 * builds of the Piral instance. This strategy ignores the fetcher and only
 * considers the already given pilets.
 */
function syncStrategy(options, cb) {
    var createApi = options.createApi, _a = options.pilets, pilets = _a === void 0 ? [] : _a;
    return evalAll(createApi, pilets, []).then(function (modules) { return cb(undefined, modules); }, function (err) { return cb(err, []); });
}
exports.syncStrategy = syncStrategy;
//# sourceMappingURL=strategies.js.map