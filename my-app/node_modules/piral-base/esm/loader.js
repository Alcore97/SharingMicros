import { __assign } from "tslib";
import { defaultFetchDependency } from './fetch';
import { createEmptyModule, getDependencyResolver } from './utils';
import { compileDependency, includeDependency, includeBundle, includeScriptDependency } from './dependency';
var inBrowser = typeof document !== 'undefined';
var depContext = {};
function loadSharedDependencies(sharedDependencies) {
    if (sharedDependencies && typeof sharedDependencies === 'object') {
        var sharedDependencyNames = Object.keys(sharedDependencies);
        return Promise.all(sharedDependencyNames.map(function (name) {
            return depContext[name] || (depContext[name] = includeScriptDependency(sharedDependencies[name]));
        }));
    }
    return Promise.resolve();
}
function loadFrom(meta, getDependencies, loadPilet) {
    var dependencies = __assign({}, (getDependencies(meta) || {}));
    return loadSharedDependencies(meta.dependencies)
        .then(function () { return loadPilet(dependencies); })
        .then(function (app) { return (__assign(__assign({}, app), meta)); });
}
export function extendLoader(fallback, specLoaders) {
    if (typeof specLoaders === 'object' && specLoaders) {
        return function (meta) {
            if (typeof meta.spec === 'string') {
                var loaderOverride = specLoaders[meta.spec];
                if (typeof loaderOverride === 'function') {
                    return loaderOverride(meta);
                }
            }
            return fallback(meta);
        };
    }
    return fallback;
}
export function createDefaultLoader(dependencies, getDependencies, fetchDependency, config) {
    var getDeps = getDependencyResolver(dependencies, getDependencies);
    return getDefaultLoader(getDeps, fetchDependency, config);
}
export function getDefaultLoader(getDependencies, fetchDependency, config) {
    if (fetchDependency === void 0) { fetchDependency = defaultFetchDependency; }
    if (config === void 0) { config = {}; }
    return function (meta) {
        if (inBrowser && 'requireRef' in meta && meta.requireRef) {
            return loadFrom(meta, getDependencies, function (deps) { return includeDependency(meta, deps, config.crossOrigin); });
        }
        else if (inBrowser && 'bundle' in meta && meta.bundle) {
            return loadFrom(meta, getDependencies, function (deps) { return includeBundle(meta, deps, config.crossOrigin); });
        }
        var name = meta.name;
        if ('link' in meta && meta.link) {
            var link_1 = meta.link;
            return fetchDependency(link_1).then(function (content) {
                return loadFrom(meta, getDependencies, function (deps) { return compileDependency(name, content, link_1, deps); });
            });
        }
        else if ('content' in meta && meta.content) {
            var content_1 = meta.content;
            return loadFrom(meta, getDependencies, function (deps) { return compileDependency(name, content_1, undefined, deps); });
        }
        else {
            console.warn('Empty pilet found!', name);
        }
        return Promise.resolve(createEmptyModule(meta));
    };
}
//# sourceMappingURL=loader.js.map