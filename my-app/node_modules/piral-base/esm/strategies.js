import { __spreadArray } from "tslib";
import { createDefaultLoader, extendLoader } from './loader';
import { loadPilets, loadMetadata } from './load';
import { createPilets, createPilet } from './aggregate';
function evalAll(createApi, oldModules, newModules) {
    if (!Array.isArray(oldModules)) {
        return Promise.reject("The existing pilets must be passed as an array.");
    }
    try {
        var _loop_1 = function (oldModule) {
            var newModule = newModules.filter(function (m) { return m.name === oldModule.name; })[0];
            if (newModule) {
                newModules.splice(newModules.indexOf(newModule), 1);
            }
        };
        for (var _i = 0, oldModules_1 = oldModules; _i < oldModules_1.length; _i++) {
            var oldModule = oldModules_1[_i];
            _loop_1(oldModule);
        }
        return createPilets(createApi, __spreadArray(__spreadArray([], oldModules), newModules));
    }
    catch (err) {
        return Promise.reject(err);
    }
}
/**
 * This strategy is dependent on the async parameter. If false it will start rendering when
 * everything has been received, otherwise it will start rendering when the metadata has been
 * received. In any case it will evaluate pilets as fast as possible.
 * @param async Uses the asynchronous mode.
 */
export function createProgressiveStrategy(async) {
    return function (options, cb) {
        var fetchPilets = options.fetchPilets, fetchDependency = options.fetchDependency, dependencies = options.dependencies, getDependencies = options.getDependencies, createApi = options.createApi, config = options.config, _a = options.pilets, pilets = _a === void 0 ? [] : _a, _b = options.loadPilet, loadPilet = _b === void 0 ? createDefaultLoader(dependencies, getDependencies, fetchDependency, config) : _b, loaders = options.loaders;
        var loader = loadMetadata(fetchPilets);
        var loadSingle = extendLoader(loadPilet, loaders);
        return createPilets(createApi, pilets).then(function (allModules) {
            if (async && allModules.length > 0) {
                cb(undefined, __spreadArray([], allModules));
            }
            var followUp = loader.then(function (metadata) {
                var promises = metadata.map(function (m) {
                    return loadSingle(m).then(function (mod) {
                        var available = pilets.filter(function (m) { return m.name === mod.name; }).length === 0;
                        if (available) {
                            return createPilet(createApi, mod).then(function (newModule) {
                                allModules.push(newModule);
                                if (async) {
                                    cb(undefined, __spreadArray([], allModules));
                                }
                            });
                        }
                    });
                });
                return Promise.all(promises).then(function () {
                    if (!async) {
                        cb(undefined, allModules);
                    }
                });
            });
            return async ? loader.then() : followUp.then();
        });
    };
}
/**
 * This strategy starts rendering when the pilets metadata has been received.
 * Evaluates the pilets once available without waiting for all pilets to be
 * available.
 */
export function blazingStrategy(options, cb) {
    var strategy = createProgressiveStrategy(true);
    return strategy(options, cb);
}
/**
 * The async strategy picked when no strategy is declared and async is set to
 * true. Directly renders, but waits for all pilets to be available before
 * evaluating them.
 */
export function asyncStrategy(options, cb) {
    standardStrategy(options, cb);
    return Promise.resolve();
}
/**
 * The standard strategy that is used if no strategy is declared and async is
 * false. Loads and evaluates all pilets before rendering.
 */
export function standardStrategy(options, cb) {
    var fetchPilets = options.fetchPilets, fetchDependency = options.fetchDependency, dependencies = options.dependencies, getDependencies = options.getDependencies, createApi = options.createApi, config = options.config, _a = options.pilets, pilets = _a === void 0 ? [] : _a, _b = options.loadPilet, loadPilet = _b === void 0 ? createDefaultLoader(dependencies, getDependencies, fetchDependency, config) : _b, loaders = options.loaders;
    var loadSingle = extendLoader(loadPilet, loaders);
    return loadPilets(fetchPilets, loadSingle)
        .then(function (newModules) { return evalAll(createApi, pilets, newModules); })
        .then(function (modules) { return cb(undefined, modules); })
        .catch(function (error) { return cb(error, []); });
}
/**
 * The strategy that could be used for special purposes, e.g., SSR or specific
 * builds of the Piral instance. This strategy ignores the fetcher and only
 * considers the already given pilets.
 */
export function syncStrategy(options, cb) {
    var createApi = options.createApi, _a = options.pilets, pilets = _a === void 0 ? [] : _a;
    return evalAll(createApi, pilets, []).then(function (modules) { return cb(undefined, modules); }, function (err) { return cb(err, []); });
}
//# sourceMappingURL=strategies.js.map