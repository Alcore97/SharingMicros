import { __assign } from "tslib";
import { cloneElement, createElement } from 'react';
import { withKey, replaceOrAddItem, removeNested } from '../utils';
export function changeLayout(ctx, current) {
    ctx.dispatch(function (state) { return (__assign(__assign({}, state), { app: withKey(state.app, 'layout', current) })); });
}
export function initialize(ctx, loading, error, modules) {
    ctx.dispatch(function (state) { return (__assign(__assign({}, state), { app: __assign(__assign({}, state.app), { error: error,
            loading: loading }), modules: modules })); });
}
export function injectPilet(ctx, pilet) {
    ctx.dispatch(function (state) { return (__assign(__assign({}, state), { modules: replaceOrAddItem(state.modules, pilet, function (m) { return m.name === pilet.name; }), registry: removeNested(state.registry, function (m) { return m.pilet === pilet.name; }) })); });
    ctx.emit('unload-pilet', {
        name: pilet.name,
    });
}
export function setComponent(ctx, name, component) {
    ctx.dispatch(function (state) { return (__assign(__assign({}, state), { components: withKey(state.components, name, component) })); });
}
export function setErrorComponent(ctx, type, component) {
    ctx.dispatch(function (state) { return (__assign(__assign({}, state), { errorComponents: withKey(state.errorComponents, type, component) })); });
}
export function setRoute(ctx, path, component) {
    ctx.dispatch(function (state) { return (__assign(__assign({}, state), { routes: withKey(state.routes, path, component) })); });
}
export function includeProvider(ctx, provider) {
    var wrapper = function (props) { return cloneElement(provider, props); };
    ctx.dispatch(function (state) { return (__assign(__assign({}, state), { provider: !state.provider ? wrapper : function (props) { return createElement(state.provider, undefined, wrapper(props)); } })); });
}
//# sourceMappingURL=app.js.map