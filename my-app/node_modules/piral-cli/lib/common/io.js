"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSourceFiles = exports.move = exports.removeFile = exports.remove = exports.copy = exports.updateExistingJson = exports.writeBinary = exports.writeText = exports.writeJson = exports.readText = exports.readBinary = exports.readJson = exports.mergeWithJson = exports.getHash = exports.updateExistingFile = exports.createFileIfNotExists = exports.matchFiles = exports.matchAny = exports.findFile = exports.getFileNames = exports.checkIsDirectory = exports.checkExistingDirectory = exports.checkExists = exports.getEntryFiles = exports.createDirectory = exports.removeDirectory = exports.removeAny = void 0;
const rimraf = require("rimraf");
const typescript_1 = require("typescript");
const path_1 = require("path");
const fs_1 = require("fs");
const fs_2 = require("fs");
const log_1 = require("./log");
const merge_1 = require("./merge");
const info_1 = require("./info");
const hash_1 = require("./hash");
const enums_1 = require("./enums");
const interactive_1 = require("./interactive");
const external_1 = require("../external");
function promptOverwrite(file) {
    const message = `The file ${file} exists already. Do you want to overwrite it?`;
    return interactive_1.promptConfirm(message, false);
}
function createDirectoryLegacy(targetDir) {
    const initDir = path_1.isAbsolute(targetDir) ? path_1.sep : '';
    return targetDir.split(path_1.sep).reduce((parentDir, childDir) => {
        const curDir = path_1.resolve(parentDir, childDir);
        try {
            fs_1.mkdirSync(curDir);
        }
        catch (err) {
            if (err.code === 'EEXIST') {
                return curDir;
            }
            if (err.code === 'ENOENT') {
                throw new Error(`EACCES: permission denied, mkdir '${parentDir}'`);
            }
            const caughtErr = ['EACCES', 'EPERM', 'EISDIR'].indexOf(err.code) > -1;
            if (!caughtErr || (caughtErr && curDir === path_1.resolve(targetDir))) {
                throw err;
            }
        }
        return curDir;
    }, initDir);
}
function isFile(file) {
    return fs_1.statSync(file).isFile();
}
function isLegacy() {
    const parts = info_1.nodeVersion.split('.');
    return +parts[0] < 10 || (+parts[0] === 10 && +parts[1] < 12);
}
function removeAny(target) {
    return __awaiter(this, void 0, void 0, function* () {
        const isDir = yield checkIsDirectory(target);
        if (isDir) {
            yield removeDirectory(target);
        }
        else {
            yield removeFile(target);
        }
    });
}
exports.removeAny = removeAny;
function removeDirectory(targetDir) {
    log_1.log('generalDebug_0003', `Removing the directory "${targetDir}" ...`);
    return new Promise((resolve, reject) => rimraf(targetDir, (err) => (err ? reject(err) : resolve())));
}
exports.removeDirectory = removeDirectory;
function createDirectory(targetDir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isLegacy()) {
            try {
                log_1.log('generalDebug_0003', `Trying to create "${targetDir}" in legacy mode ...`);
                createDirectoryLegacy(targetDir);
                return true;
            }
            catch (e) {
                log_1.log('cannotCreateDirectory_0044');
                log_1.log('generalDebug_0003', `Error while creating ${targetDir}: ${e}`);
                return false;
            }
        }
        try {
            log_1.log('generalDebug_0003', `Trying to create "${targetDir}" in modern mode ...`);
            yield new Promise((resolve, reject) => {
                fs_1.mkdir(targetDir, { recursive: true }, (err) => (err ? reject(err) : resolve()));
            });
            return true;
        }
        catch (e) {
            log_1.log('cannotCreateDirectory_0044');
            log_1.log('generalDebug_0003', `Error while creating ${targetDir}: ${e}`);
            return false;
        }
    });
}
exports.createDirectory = createDirectory;
function getEntryFiles(content, basePath) {
    return __awaiter(this, void 0, void 0, function* () {
        log_1.log('generalDebug_0003', `Extract entry files from "${basePath}".`);
        const matcher = /<script\s.*?src=(?:"(.*?)"|'(.*?)'|([^\s>]*)).*?>/gi;
        const results = [];
        let result = undefined;
        while ((result = matcher.exec(content))) {
            const src = result[1] || result[2] || result[3];
            log_1.log('generalDebug_0003', `Found potential entry file "${src}".`);
            const filePath = path_1.resolve(basePath, src);
            const exists = yield checkExists(filePath);
            if (exists) {
                results.push(filePath);
            }
        }
        return results;
    });
}
exports.getEntryFiles = getEntryFiles;
function checkExists(target) {
    return new Promise((resolve) => {
        if (target !== undefined) {
            fs_1.exists(target, resolve);
        }
        else {
            resolve(false);
        }
    });
}
exports.checkExists = checkExists;
function checkExistingDirectory(target) {
    return __awaiter(this, void 0, void 0, function* () {
        log_1.log('generalDebug_0003', `Checking directory "${target}" ...`);
        if (yield checkExists(target)) {
            log_1.log('generalDebug_0003', `Target exists, but not yet clear if directory.`);
            return yield checkIsDirectory(target);
        }
        return false;
    });
}
exports.checkExistingDirectory = checkExistingDirectory;
function checkIsDirectory(target) {
    return new Promise((resolve) => {
        fs_1.lstat(target, (err, stats) => {
            if (err) {
                resolve(path_1.extname(target) === '');
            }
            else {
                resolve(stats.isDirectory());
            }
        });
    });
}
exports.checkIsDirectory = checkIsDirectory;
function getFileNames(target) {
    return new Promise((resolve, reject) => {
        fs_2.readdir(target, (err, files) => (err ? reject(err) : resolve(files)));
    });
}
exports.getFileNames = getFileNames;
function findFile(topDir, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        const path = path_1.join(topDir, fileName);
        const exists = yield checkExists(path);
        if (!exists) {
            const parentDir = path_1.resolve(topDir, '..');
            if (parentDir !== topDir) {
                return yield findFile(parentDir, fileName);
            }
            return undefined;
        }
        return path;
    });
}
exports.findFile = findFile;
function matchPattern(baseDir, pattern) {
    return new Promise((resolve, reject) => {
        external_1.glob(pattern, {
            cwd: baseDir,
            nodir: true,
        }, (err, files) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(files);
            }
        });
    });
}
function matchAnyPattern(baseDir, pattern) {
    return __awaiter(this, void 0, void 0, function* () {
        const matches = yield Promise.all(pattern.patterns.map((pattern) => matchPattern(baseDir, pattern)));
        return {
            pattern: pattern.original,
            results: matches.reduce((agg, curr) => [...agg, ...curr], []),
        };
    });
}
const preferences = ['.tsx', '.ts', '.jsx', '.js', '.mjs', '.cjs', '.esm', '.es', '.es6', '.html'];
function matchAny(baseDir, patterns) {
    return __awaiter(this, void 0, void 0, function* () {
        const matches = [];
        const exts = preferences.map((s) => s.substr(1)).join(',');
        const allPatterns = patterns.reduce((agg, curr) => {
            const patterns = [];
            if (/[a-zA-Z0-9\-]+$/.test(curr) && !preferences.find((ext) => curr.endsWith(ext))) {
                patterns.push(curr, `${curr}.{${exts}}`, `${curr}/package.json`);
            }
            else if (curr.endsWith('/')) {
                patterns.push(`${curr}index.{${exts}}`, `${curr}package.json`);
            }
            else {
                patterns.push(curr);
            }
            agg.push({ original: curr, patterns });
            return agg;
        }, []);
        yield Promise.all(allPatterns.map((patterns) => matchAnyPattern(baseDir, patterns).then(({ results, pattern }) => __awaiter(this, void 0, void 0, function* () {
            if (!results.length) {
                //TODO emit warning
            }
            else {
                log_1.log('generalDebug_0003', `Found ${results.length} potential entry points in "${pattern}".`);
                // only take first / primary result
                const firstResult = results[0];
                const fileName = path_1.basename(firstResult);
                if (fileName === 'package.json') {
                    log_1.log('generalDebug_0003', `Entry point is a "package.json" and needs further inspection.`);
                    const targetDir = path_1.dirname(firstResult);
                    const { source } = yield readJson(targetDir, fileName);
                    if (typeof source === 'string') {
                        log_1.log('generalDebug_0003', `Found a "source" field with value "${source}".`);
                        const target = path_1.resolve(targetDir, source);
                        const exists = yield checkExists(target);
                        if (exists) {
                            log_1.log('generalDebug_0003', `Taking existing target as "${target}".`);
                            matches.push(target);
                        }
                        else {
                            log_1.log('generalDebug_0003', `Source target "${target}" does not exist. Skipped.`);
                        }
                    }
                    else {
                        log_1.log('generalDebug_0003', `No "source" field found. Trying combinations in "src".`);
                        const files = yield matchPattern(baseDir, `src/index.{${exts}}`);
                        if (files.length > 0) {
                            log_1.log('generalDebug_0003', `Found a result; taking "${files[0]}".`);
                            matches.push(files[0]);
                        }
                        else {
                            log_1.log('generalDebug_0003', `Found no results in "src". Skipped.`);
                        }
                    }
                }
                else {
                    log_1.log('generalDebug_0003', `Entry point result is "${firstResult}".`);
                    matches.push(firstResult);
                }
            }
        }))));
        return matches;
    });
}
exports.matchAny = matchAny;
function matchFiles(baseDir, pattern) {
    return new Promise((resolve, reject) => {
        external_1.glob(pattern, {
            cwd: baseDir,
            absolute: true,
            dot: true,
        }, (err, files) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(files.filter(isFile));
            }
        });
    });
}
exports.matchFiles = matchFiles;
function createFileIfNotExists(targetDir, fileName, content, forceOverwrite = enums_1.ForceOverwrite.no) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = path_1.join(targetDir, fileName);
        log_1.log('generalDebug_0003', `Checking if file "${targetFile}" exists ...`);
        const exists = yield checkExists(targetFile);
        if (!exists ||
            forceOverwrite === enums_1.ForceOverwrite.yes ||
            (forceOverwrite === enums_1.ForceOverwrite.prompt && (yield promptOverwrite(targetFile)))) {
            yield createDirectory(path_1.dirname(targetFile));
            log_1.log('generalDebug_0003', `Creating file "${targetFile}" ...`);
            if (typeof content === 'string') {
                yield writeText(targetDir, fileName, content);
            }
            else {
                yield writeBinary(targetDir, fileName, content);
            }
        }
    });
}
exports.createFileIfNotExists = createFileIfNotExists;
function updateExistingFile(targetDir, fileName, content) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = path_1.join(targetDir, fileName);
        log_1.log('generalDebug_0003', `Checking if file "${targetFile}" exists ...`);
        const exists = yield checkExists(targetFile);
        if (exists) {
            log_1.log('generalDebug_0003', `Updating file "${targetFile}" ...`);
            yield new Promise((resolve, reject) => {
                fs_2.writeFile(targetFile, content, 'utf8', (err) => (err ? reject(err) : resolve()));
            });
        }
    });
}
exports.updateExistingFile = updateExistingFile;
function getHash(targetFile) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            fs_2.readFile(targetFile, (err, c) => (err ? resolve(undefined) : resolve(hash_1.computeHash(c))));
        });
    });
}
exports.getHash = getHash;
function mergeWithJson(targetDir, fileName, newContent) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = path_1.join(targetDir, fileName);
        const content = yield new Promise((resolve, reject) => {
            fs_2.readFile(targetFile, 'utf8', (err, c) => (err ? reject(err) : resolve(c)));
        });
        const originalContent = JSON.parse(content);
        return merge_1.deepMerge(originalContent, newContent);
    });
}
exports.mergeWithJson = mergeWithJson;
function readJson(targetDir, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = path_1.join(targetDir, fileName);
        const content = yield new Promise((resolve) => {
            fs_2.readFile(targetFile, 'utf8', (err, c) => (err ? resolve('') : resolve(c)));
        });
        return JSON.parse(content || '{}');
    });
}
exports.readJson = readJson;
function readBinary(targetDir, fileName) {
    const targetFile = path_1.join(targetDir, fileName);
    return new Promise((resolve) => {
        fs_2.readFile(targetFile, (err, c) => (err ? resolve(undefined) : resolve(c)));
    });
}
exports.readBinary = readBinary;
function readText(targetDir, fileName) {
    const targetFile = path_1.join(targetDir, fileName);
    return new Promise((resolve) => {
        fs_2.readFile(targetFile, 'utf8', (err, c) => (err ? resolve(undefined) : resolve(c)));
    });
}
exports.readText = readText;
function writeJson(targetDir, fileName, data, beautify = false) {
    const content = beautify ? JSON.stringify(data, undefined, 2) : JSON.stringify(data);
    return writeText(targetDir, fileName, content);
}
exports.writeJson = writeJson;
function writeText(targetDir, fileName, content) {
    const data = Buffer.from(content, 'utf8');
    return writeBinary(targetDir, fileName, data);
}
exports.writeText = writeText;
function writeBinary(targetDir, fileName, data) {
    const targetFile = path_1.join(targetDir, fileName);
    return new Promise((resolve, reject) => {
        fs_2.writeFile(targetFile, data, (err) => (err ? reject(err) : resolve()));
    });
}
exports.writeBinary = writeBinary;
function updateExistingJson(targetDir, fileName, newContent) {
    return __awaiter(this, void 0, void 0, function* () {
        const content = yield mergeWithJson(targetDir, fileName, newContent);
        yield updateExistingFile(targetDir, fileName, JSON.stringify(content, undefined, 2));
    });
}
exports.updateExistingJson = updateExistingJson;
function copy(source, target, forceOverwrite = enums_1.ForceOverwrite.no) {
    return __awaiter(this, void 0, void 0, function* () {
        yield createDirectory(path_1.dirname(target));
        try {
            const flag = forceOverwrite === enums_1.ForceOverwrite.yes ? 0 : fs_2.constants.COPYFILE_EXCL;
            yield new Promise((resolve, reject) => {
                fs_2.copyFile(source, target, flag, (err) => (err ? reject(err) : resolve()));
            });
            return true;
        }
        catch (e) {
            if (forceOverwrite === enums_1.ForceOverwrite.prompt) {
                const shouldOverwrite = yield promptOverwrite(target);
                if (shouldOverwrite) {
                    return yield copy(source, target, enums_1.ForceOverwrite.yes);
                }
            }
            else {
                log_1.log('didNotOverWriteFile_0045', target);
            }
        }
        return false;
    });
}
exports.copy = copy;
/**
 * @deprecated Will be removed with v1. Please use "removeFile".
 */
function remove(target) {
    return removeFile(target);
}
exports.remove = remove;
function removeFile(target) {
    return new Promise((resolve, reject) => {
        fs_1.unlink(target, (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
exports.removeFile = removeFile;
function move(source, target, forceOverwrite = enums_1.ForceOverwrite.no) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = yield checkIsDirectory(target);
        if (dir) {
            const file = path_1.basename(source);
            target = path_1.resolve(target, file);
        }
        const success = yield copy(source, target, forceOverwrite);
        if (success) {
            yield removeFile(source);
            return target;
        }
        return source;
    });
}
exports.move = move;
function getSourceFiles(entry) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = path_1.dirname(entry);
        log_1.log('generalDebug_0003', `Trying to get source files from "${dir}" ...`);
        const files = yield matchFiles(dir, '**/*.?(jsx|tsx|js|ts)');
        return files.map((path) => {
            const directory = path_1.dirname(path);
            const name = path_1.basename(path);
            return {
                path,
                directory,
                name,
                read() {
                    return __awaiter(this, void 0, void 0, function* () {
                        const content = yield readText(directory, name);
                        if (name.endsWith('.ts') || name.endsWith('.tsx')) {
                            return typescript_1.transpileModule(content, {
                                fileName: path,
                                moduleName: name,
                                compilerOptions: {
                                    allowJs: true,
                                    skipLibCheck: true,
                                    declaration: false,
                                    sourceMap: false,
                                    checkJs: false,
                                    jsx: typescript_1.JsxEmit.React,
                                    module: typescript_1.ModuleKind.ESNext,
                                    moduleResolution: typescript_1.ModuleResolutionKind.NodeJs,
                                    target: typescript_1.ScriptTarget.ESNext,
                                },
                            }).outputText;
                        }
                        return content;
                    });
                },
            };
        });
    });
}
exports.getSourceFiles = getSourceFiles;
//# sourceMappingURL=io.js.map