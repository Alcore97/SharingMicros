"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWebpack = void 0;
const webpack = require("webpack");
const path_1 = require("path");
const events_1 = require("events");
function getOutput(stats) {
    const { outputPath, entrypoints } = stats.toJson();
    const assets = entrypoints.main.assets;
    return path_1.resolve(outputPath, assets[0]);
}
function getPreset(logLevel) {
    switch (logLevel) {
        case 0: //LogLevels.disabled
            return 'none';
        case 1: //LogLevels.error
            return 'errors-only';
        case 2: //LogLevels.warning
            return 'errors-warnings';
        case 4: //LogLevels.verbose
        case 5: //LogLevels.debug
            return 'verbose';
        case 3: //LogLevels.info
        default:
            return 'normal';
    }
}
function runWebpack(wpConfig, logLevel) {
    const eventEmitter = new events_1.EventEmitter();
    const outDir = wpConfig.output.path;
    const preset = webpack.Stats.presetToOptions(getPreset(logLevel));
    const mainBundle = {
        name: '',
        requireRef: undefined,
        entryAsset: {
            hash: '',
        },
    };
    wpConfig.plugins.push({
        apply(compiler) {
            compiler.hooks.beforeCompile.tap('piral-cli', () => {
                eventEmitter.emit('buildStart');
            });
            compiler.hooks.done.tap('piral-cli', (stats) => {
                var _a, _b;
                mainBundle.name = getOutput(stats);
                mainBundle.requireRef = (_b = (_a = stats.compilation.outputOptions) === null || _a === void 0 ? void 0 : _a.jsonpFunction) === null || _b === void 0 ? void 0 : _b.replace('_chunks', '');
                mainBundle.entryAsset.hash = stats.hash;
                eventEmitter.emit('bundled');
            });
        },
    });
    const bundle = () => new Promise((resolve, reject) => {
        webpack(wpConfig, (err, stats) => {
            if (err) {
                console.error(err);
                reject(err);
            }
            else {
                console.log(stats.toString(Object.assign(Object.assign({}, preset), { colors: true })));
                if (stats.hasErrors()) {
                    reject(stats.toJson(preset));
                }
                else {
                    const file = getOutput(stats);
                    resolve({
                        outFile: `/${path_1.basename(file)}`,
                        outDir: path_1.dirname(file),
                    });
                }
            }
        });
    });
    return {
        bundle,
        on(ev, listener) {
            eventEmitter.on(ev, listener);
        },
        off(ev, listener) {
            eventEmitter.off(ev, listener);
        },
        options: {
            outDir,
        },
        mainBundle,
    };
}
exports.runWebpack = runWebpack;
//# sourceMappingURL=bundler-run.js.map